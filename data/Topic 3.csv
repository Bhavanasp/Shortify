id,answer,link,code,sim score,sc
48123619.0,"I am assuming you want to create comment and reply(re-comment) on particular comment on detail page of Post model.You can create a View inspite of creating a CreateView for  CommentCreateView and ReCommentCreateView class and override post methodNow send ReCommentCreateForm and CommentCreateForm in context data of your DetailView class.In your comment.html you can use both variable to render form.Update your urls for all views like below.Access your post detail page using:
  http://localhost:8000/polls/post/1/",,"Post
View
CreateView
post
class CommentCreateView(generic.View):

   def post(self, request, *args, **kwargs):
      form = CommentCreateForm(request.POST)
      post = Post.objects.get(pk=kwargs['post_pk'])
      if form.is_valid():
        obj = form.save(commit=False)
        obj.target = post
        obj.save()
      return redirect('detail', pk=post.pk)

class ReCommentCreateView(generic.View):

   def post(self, request, *args, **kwargs):
      form = ReCommentCreateForm(request.POST)
      comment = Comment.objects.get(pk=kwargs['comment_pk'])
      if form.is_valid():
        obj = form.save(commit=False)
        obj.target = comment
        obj.save()
      return redirect('detail', pk=comment.target.pk)

ReCommentCreateForm
CommentCreateForm
class DetailView(generic.DetailView):
    model = Post
    template_name = 'comment.html'

    def get_context_data(self, **kwargs):
       context = super().get_context_data(**kwargs)
       context['comment_form'] = CommentCreateForm()
       context['recomment_form'] = ReCommentCreateForm()
       return context 

# comment form action url should have id of post.
<form action=""{% url 'comment' post_pk=post.id %}"" method=""post"">
   {{comment_form}}
   {% csrf_token %}
   <input class=""btn btn-primary"" type=""submit"" value=""comment""> 
</form>

# re-comment form action url should have id of comment on which user is replying.
<form action=""{% url 'recomment' comment_pk=comment.id %}"" method=""post"">
   {{recomment_form}}
   {% csrf_token %}
   <input class=""btn btn-primary"" type=""submit"" value=""re-comment"">
</form>

urlpatterns = [    
    # Detail page of post url 
    path('post/<int:pk>/', views.DetailView.as_view(), name='post'),
    # CommentCreateView page url to create comment on post
    path('comment/<int:post_pk>/', views.CommentCreateView.as_view(), name='comment'),
    # ReCommentCreateView page url to create re-comment on comment
    path('recomment/<int:comment_pk>/', views.ReCommentCreateView.as_view(), name='recomment'),
]

http://localhost:8000/polls/post/1/",1.0,4.0
52480347.0,Use cumcount for counter column in both DataFrames and add this column to parameter on in merge:Details:,http://pandas.pydata.org/pandas-docs/stable/generated/pandas.core.groupby.GroupBy.cumcount.html,"cumcount
DataFrame
on
merge
df1['g'] = df1.groupby('IDs').cumcount()
df2['g'] = df2.groupby('IDs').cumcount()

df3 = pd.merge(df1,df2,on=['IDs', 'g']).drop('g', axis=1)
print (df3)
  IDs  Value1  Value2 Issue
0  AB       1       3    AA
1  AB       1       1   AAA
2  AB       2       4    BA
3  BC       2       2    CC
4  BC       5       0    CA
5  BG       1       1     A
6  RF       2       2     D

print (df1)
  IDs  Value1  Value2  g
0  AB       1       3  0
1  AB       1       1  1
2  AB       2       4  2
3  BC       2       2  0
4  BC       5       0  1
5  BG       1       1  0
6  RF       2       2  0

print (df2)
  IDs Issue  g
0  AB    AA  0
1  AB   AAA  1
2  AB    BA  2
3  BC    CC  0
4  BC    CA  1
5  BG     A  0
6  RF     D  0
",0.85,3.690277730693587
43948049.0,"There are many ways to do this, staying in Pandas I did the following.With the file structureThis code will work, it's a little verbose for explanation but you can shorten with implementation.",,"root/  
├── dir1/  
│   ├── data_20170101_k   
│   ├── data_20170102_k    
│   ├── ...  
├── dir2/    
│   ├── data_20170101_k    
│   └── data_20170101_k  
│   └── ...   
└── ... 

import glob
import pandas as pd

CONCAT_DIR = ""/FILES_CONCAT/""

# Use glob module to return all csv files under root directory. Create DF from this.
files = pd.DataFrame([file for file in glob.glob(""root/*/*"")], columns=[""fullpath""])

#    fullpath
# 0  root\dir1\data_20170101_k.csv
# 1  root\dir1\data_20170102_k.csv
# 2  root\dir2\data_20170101_k.csv
# 3  root\dir2\data_20170102_k.csv

# Split the full path into directory and filename
files_split = files['fullpath'].str.rsplit(""\\"", 1, expand=True).rename(columns={0: 'path', 1:'filename'})

#    path       filename
# 0  root\dir1  data_20170101_k.csv
# 1  root\dir1  data_20170102_k.csv
# 2  root\dir2  data_20170101_k.csv
# 3  root\dir2  data_20170102_k.csv

# Join these into one DataFrame
files = files.join(files_split)

#    fullpath                       path        filename
# 0  root\dir1\data_20170101_k.csv  root\dir1   data_20170101_k.csv
# 1  root\dir1\data_20170102_k.csv  root\dir1   data_20170102_k.csv
# 2  root\dir2\data_20170101_k.csv  root\dir2   data_20170101_k.csv
# 3  root\dir2\data_20170102_k.csv  root\dir2   data_20170102_k.csv

# Iterate over unique filenames; read CSVs, concat DFs, save file
for f in files['filename'].unique():
    paths = files[files['filename'] == f]['fullpath'] # Get list of fullpaths from unique filenames
    dfs = [pd.read_csv(path, header=None) for path in paths] # Get list of dataframes from CSV file paths
    concat_df = pd.concat(dfs) # Concat dataframes into one
    concat_df.to_csv(CONCAT_DIR + f) # Save dataframe
",1.0,3.662520010236776
47667379.0,"You'll have to learn how templating works. Read this page on the docs to learn more: http://www.tornadoweb.org/en/stable/guide/templates.html#template-syntax After that, you can find the complete template syntax reference on this page: http://www.tornadoweb.org/en/stable/template.html#syntax-referenceAnyway, you can ""merge"" two templates and render them as one by using the {% include %} template tag. Example:Your Home1.html template should look roughly like this:Then render only the Home1.html from your request handler.This answer is far from perfect. You'll have to invest some time to actually learn about templates.",http://www.tornadoweb.org/en/stable/guide/templates.html#template-syntax http://www.tornadoweb.org/en/stable/template.html#syntax-reference,"{% include %}
Home1.html
<html>
    <!-- do something -->
    {% include 'Home2.html' %}
    <!-- do something else -->
</html>

Home1.html",1.0,3.102712651059857
59513995.0,Verified solution (using heapq.merge):Prints:On leetcode it was classified as Success (link):,https://docs.python.org/3.8/library/heapq.html#heapq.merge https://leetcode.com/submissions/detail/289269685/ https://i.stack.imgur.com/2A4zb.png,"heapq.merge
from heapq import merge

class ListNode(object):
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution(object):
    def mergeTwoLists(self, l1, l2):
        """"""
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        """"""

        def iter_list(l):
            v = l
            while v:
                yield v
                v = v.next

        def create_nodes():
            l = ListNode(None)
            val = yield l
            l.val = val
            while True:
                val = yield
                l.next = ListNode(val)
                l = l.next

        creator = create_nodes()
        rv = next(creator)
        for v in merge(iter_list(l1), iter_list(l2), key=lambda k: k.val):
            creator.send(v.val)

        return None if rv.val is None else rv

 # [1,2,4] and [1,3,4]
l1 = ListNode(1)
l1.next = ListNode(2)
l1.next.next = ListNode(4)

l2 = ListNode(1)
l2.next = ListNode(3)
l2.next.next = ListNode(4)

def print_list(l):
    v = l
    while v:
        print(v.val)
        v = v.next

new_list_node = Solution().mergeTwoLists(l1, l2)
print_list(new_list_node)

1
1
2
3
4
4

leetcode",1.0,2.9750495637309715
52879192.0,"A way you could do it and which would result in cleaner code in to define a function that takes two JSON objects and return the combination of those two.Then, after you have output_list:Result will be the object you are looking for.If you're not familiar with the reduce function, check out this web page: http://book.pythontips.com/en/latest/map_filter.htmlIt briefly explains the usage of reduce, as well as map and filter. They are very useful.",http://book.pythontips.com/en/latest/map_filter.html,"def merge (json_obj_1, json_obj_2):
    items = json_obj_1['items'] + json_obj_2['items']
    return { 'items': items }

result = reduce(merge, output_list)
",1.0,2.7773022159247835
57508214.0,"Just use a defaultdict.items is a list of your initial lists.
grouped_list will be a list of the grouped lists by uid.",,"defaultdict
import collections

def group_items(items):
    grouped_dict = collections.defaultdict(list)
    for item in items:
        uid = item[0]
        t = item[1]
        grouped_dict[uid].append(t)

    grouped_list = []
    for uid, tuples in grouped_dict.iteritems():
        grouped_list.append([uid] + tuples)

    return grouped_list

items
grouped_list",0.85,2.6726882294629744
38745759.0,"do you have a views.py which serves these models? you could easily use the django render function to serve all three of these models to the dom. this is a rather comprehensive, all encompassing process but I'd be more than happy to assist you ",https://docs.djangoproject.com/en/1.9/topics/http/shortcuts/#render,,0.0,0.0
