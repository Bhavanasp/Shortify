answer,link,code,sc
"You cannot have multiple colors in a label. If you want multiple colors, use a one-line Text widget, or use a canvas with a text item. Here's a quick and dirty example using a text widget. It doesn't do smooth scrolling, doesn't use any real data, and leaks memory since I never trim the text in the input widget, but it gives the general idea:",,"import Tkinter as tk
import random

class Example(tk.Frame):
    def __init__(self, parent):
        tk.Frame.__init__(self, parent)
        self.ticker = tk.Text(height=1, wrap=""none"")
        self.ticker.pack(side=""top"", fill=""x"")

        self.ticker.tag_configure(""up"", foreground=""green"")
        self.ticker.tag_configure(""down"", foreground=""red"")
        self.ticker.tag_configure(""event"", foreground=""black"")

        self.data = [""AAPL"", ""GOOG"", ""MSFT""]
        self.after_idle(self.tick)

    def tick(self):
        symbol = self.data.pop(0)
        self.data.append(symbol) 

        n = random.randint(-1,1)
        tag = {-1: ""down"", 0: ""even"", 1: ""up""}[n]

        self.ticker.configure(state=""normal"")
        self.ticker.insert(""end"", "" %s %s"" % (symbol, n), tag)
        self.ticker.see(""end"")
        self.ticker.configure(state=""disabled"")
        self.after(1000, self.tick)

if __name__ == ""__main__"":
    root = tk.Tk()
    Example(root).pack(fill=""both"", expand=True)
    root.mainloop()
",2.6666666666666665
try pandas.DataFrame.updateModify DataFrame in place using non-NA values from passed DataFrame. Aligns on indices,http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.update.html,"DataFrame.update(other, join='left', overwrite=True,
                 filter_func=None, raise_conflict=False)
",1.7918267930666745
"The answer to all 3 of your questions is yes, you can use stderr=subprocess.STDOUT as an argument to Popen to redirect output from stderr to stdout:",,"stderr=subprocess.STDOUT
Popen
stderr
stdout
self.process = Popen(command, stdout=PIPE, stderr=subprocess.STDOUT)
",1.3324463091220866
"Just use a defaultdict.items is a list of your initial lists.
grouped_list will be a list of the grouped lists by uid.",,"defaultdict
import collections

def group_items(items):
    grouped_dict = collections.defaultdict(list)
    for item in items:
        uid = item[0]
        t = item[1]
        grouped_dict[uid].append(t)

    grouped_list = []
    for uid, tuples in grouped_dict.iteritems():
        grouped_list.append([uid] + tuples)

    return grouped_list

items
grouped_list",1.1412902453890224
"That's the editor that is opened so that you can write the commit message. That means the merge went well, no conflicts. Just set the comment, save the file and quit and the merge revision should be done.",,,1.0584015442864283
"This can be achieved in much simple way in shell as:(Note: Don't use .csv in extension as it will cause inconsistency with find. After this command is finished, file can be renamed as .csv",,"find . -name ""*.csv"" | xargs cat > mergedCSV
",1.0508696231575516
I would try to create a temporary key to join on:Output:,,"#unzip list_of_couples into index for table_a and table_b
a, b  = zip(*list_of_couples)

#Loop on length of index to assign same value of key to each table for the appropriate index
for i in range(len(a)):
    df_a.loc[a[i], 'key'] = i
    df_b.loc[b[i], 'key'] = i

#merge dataframes on 'key', remove NaN records and drop temporary 'key' column
df_a.merge(df_b, on='key').dropna(subset=['key']).drop('key', axis=1)

   col_a  col_b  col_c  col_d
0      1      2      9      8
5      1      1      3      3
",0.3167271146423417
Use this code :Ouptut:,,"list1= [['user1', 186, 'Feb 2017, Apr 2017', 550, 555], ['user2', 282, 'Mai 2017', 0, 3579], ['user3', 281, 'Mai 2017', 10, 60]]

list2= [['user1', 186, 'Feb 2017, Mar 2017, Mai 2017', 0, 740],['user2', 282, 'Feb 2017', 0, 1000], ['user4', 288, 'Feb 2017', 60, 10]]

final_list = []
for l1_data, l2_data in zip(list1, list2):
    if l1_data[0] == l2_data[0]:
        for index, elem in enumerate(l2_data):
            if index+1 <= len(l1_data):
                if not elem and l1_data[index]:
                    l2_data[index] = l1_data[index]                    
    else: final_list.append(l1_data)
    final_list.append(l2_data)
print final_list

[['user1', 186, 'Feb 2017, Mar 2017, Mai 2017', 550, 740], ['user2', 282, 'Feb 2017', 0, 1000], ['user3', 281, 'Mai 2017', 10, 60], ['user4', 288, 'Feb 2017', 60, 10]]
",0.16666666666666666
